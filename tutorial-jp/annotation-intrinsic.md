Bytespresso: Annotation @Intrinsic
==


仕様
--
- 対象: staticメソッド
	- 引数の型はObjectに限られる
	- 返り値の型はprimitiveな型またはその配列に限られる
- 記法: @Intrinsic
	- 対象となるメソッドのbodyにJavaコードで変換のルールを記述する。


説明
--

@IntrinsicアノテーションはNativeコードを扱う仕組みの一つ。高度な最適化をする時に用いられる。

- @IntrinsicはメソッドのbodyがCコード変換のためのコードとして働くよう指示するものである。@Intrinsicを付与するJavaメソッドは、Cコードへの変換時に呼び出される。そのため@Intrinsicを外した時、そのコードがちゃんと動くことは期待できない。
- @Intrinsicを付与したメソッドはCコードとして出力する文字列を直接扱うことができるためOpenMPの指示文やCプリプロセッサマクロを吐くこともできる。
-  @Intrinsicと@Nativeや@Foreignは次のように使い分ける
	- @NativeはJavaのコードをCのコードブロックを含んだ関数呼び出し）に置き換えるものである。@Nativeを付与したJavaメソッドを呼び出すコードが変換コード中に存在すると、@Nativeの引数をbodyとするC関数定義が出力される。
	- @Foreignは、Javaの関数呼び出しを、既に存在するC関数への呼び出しに置き換えるもの。（必ずしもそうする必要はないが流儀として）@Foreignを付与するJavaメソッドには、そのメソッドがCコードに変換されずにJavaコードとして解釈された時のコードを書く。
	- @Intrinsicは、このアノテーションが付与されているJavaメソッドを「呼び出すコード」を、どのように変換するかを、Javaメソッドのコードの中に書く。@Nativeや@Foreignは「呼び出すコード」については、何らかのC関数呼び出しに置き換えられるだけである。

@Intrinsicを付与するJavaメソッドのbodyに記述するCコードへの出力はCCodeクラスを介して行う。CCodeクラスに定義されているメソッドのうち代表的なものは以下のとおり。

- inTranslation()
	- Cコードに変換されている最中に呼び出されたかを判定するメソッド。trueの値をとる場合は、Cコードへの変換を有効にし、そうでない場合は、無効にする一方、@Intrinsicアノテーションを無視してJavaコードからこのメソッドが呼び出された時の意味を与える。
- make(String)
	- 引数の文字列をCコードとして出力するためのバッファに蓄える。
	- 初回はmakeを使い、2回目以降はaddを使う。
- add(String)
	- 引数の文字列をCコードとして出力するためのバッファに蓄える。
	- 初回はmakeを使い、2回目以降はaddを使う。
- newLine()
	-	改行文字をCコードとして出力するためのバッファに蓄える。 
- emit()
	- バッファに蓄えられたCコードをbytespresso.cに吐き出す。

また、@Intrinsicを付与するJavaメソッドの引数は、Object型の物に限られるという制限がある。この引数をCode型にキャストすると、引数として記述している構文要素が文字列として引き渡される。以下、利用例の節にて具体例で説明する。

利用例
--

@Intrinsicを使い、第2引数として与えられたJavaの式の評価を、第1引数で与えられた数値の回数分繰り返すコードを出力する例を示す。

```Java
package sample;

import javassist.offload.Intrinsic;
import javassist.offload.javatoc.CCode;
import javassist.offload.Code;
import javassist.offload.javatoc.StdDriver;
import javassist.offload.lib.Util;

public class AnnotationIntrinsic {
        
	@Intrinsic
	public static void repeat(Object niter, Object exp) {
		if (CCode.inTranslation()) {
			CCode cc = CCode.make("// code generated by @Intrinsic").newLine();
			for (int i = 0; i < 5; i++) {
				cc.add("// #" + i + "\n");
				cc.add((Code)exp).add(";\n");
			}
			cc.emit();
		}
	}
		
    public static void main(String[] args) throws Exception {
    	new StdDriver().invoke(() -> {
    		Util.printer.p("Hello, Annotation Intrinsic").ln();
    		repeat(5, Util.printer.p("kick!").ln());
    	});
    }
}
```

StdDriverに変換を依頼しているJava Lambda式には、repeatメソッドの呼び出しが記述されているが、このrepeatメソッドの第2引数の式は、第1引数の値の回数（5回）評価されるコードが出力される。

そのため実行結果は以下のようになる。

```
Hello, Annotation Intrinsic
kick!
kick!
kick!
kick!
kick!
```

当該のJava Lambda式は次のようなCコードとしてbytespresso.cに出力されている。

```C
void AnnotationIntrinsic_lambda_0_2() {

  Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\33\0\0\0" "Hello, Annotation Intrinsic")));
  // code generated by @Intrinsic
// #0
Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\5\0\0\0" "kick!")));
// #1
Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\5\0\0\0" "kick!")));
// #2
Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\5\0\0\0" "kick!")));
// #3
Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\5\0\0\0" "kick!")));
// #4
Util_Printer_ln_7(Util_Printer_p_3_0(&gvar0, ((struct java_string*)"\2\0\0\0\5\0\0\0" "kick!")));
;
  return ;
}
```

一般的なJavaの構文として考えると、repeat引数の第2引数は、1度だけ評価され、その結果がrepeatメソッドの引数として渡されるはずだが、このプログラム例においては、当該の第2引数の式は評価される前にrepeatメソッドに渡されていることにご留意いただきたい。
