// Copyright (C) 2016- Shigeru Chiba.  All Rights Reserved.

package javassist.offload.reify;

import java.util.ArrayList;
import javassist.*;
import javassist.bytecode.*;

/**
 * A sort of basic block although it may have multiple exits.
 * It is generated by a stack-map-table attribute. 
 */
public class BasicBlock {
    static class Reader extends StackMapTable.Walker {
        ClassPool classPool;
        ConstPool constPool;
        BasicBlock[] blocks;
        int index;

        public Reader(StackMapTable smt, ClassPool cp, CtClass clazz, MethodInfo minfo)
            throws NotFoundException
        {
            super(smt);
            blocks = new BasicBlock[size() + 1];
            blocks[0] = new BasicBlock(getInitLocals(cp, clazz, minfo), new CtClass[0]);
            classPool = cp;
            constPool = clazz.getClassFile2().getConstPool();
            index = 0;
        }

        public BasicBlock[] getBlocks() {
            if (index + 1 == blocks.length)
                return blocks;

            BasicBlock[] newBlocks = new BasicBlock[blocks.length - 1];
            for (int i = 0; i < newBlocks.length; i++)
                newBlocks[i] = blocks[i];

            return newBlocks;
        }

        public void sameFrame(int pos, int offsetDelta) {
            if (offsetDelta == 0 && index == 0) {
                // the first block is a jump target.
                blocks[0].offset = 0;
                return;
            }

            BasicBlock bb = new BasicBlock(blocks[index].locals, new CtClass[0],
                                           blocks[index].offset + offsetDelta + 1);
            blocks[++index] = bb;
        }

        public void sameLocals(int pos, int offsetDelta, int stackTag, int stackData)
            throws BadBytecode
        {
            CtClass type = toCtClass(stackTag, stackData);
            int typeSize = type != null && type.isPrimitive()
                                ? ((CtPrimitiveType)type).getDataSize() : 1;
            BasicBlock prev = blocks[index];
            CtClass[] stack = new CtClass[prev.stack.length + typeSize];
            copy(prev.stack, stack, 0, prev.stack.length);
            stack[prev.stack.length] = toCtClass(stackTag, stackData);
            BasicBlock bb = new BasicBlock(prev.locals, stack, prev.offset + offsetDelta + 1);
            blocks[++index] = bb;
        }

        public void chopFrame(int pos, int offsetDelta, int k) {
            CtClass[] prevLocals = blocks[index].locals;
            boolean[] sizes = new boolean[prevLocals.length];
            for (int i = 0; i < sizes.length; i++) {
                CtClass type = prevLocals[i];
                if (type != null && type.isPrimitive() && ((CtPrimitiveType)type).getDataSize() > 1) {
                    sizes[i++] = true;
                    sizes[i] = true;
                }
                else
                    sizes[i] = false;
            }

            int j = sizes.length - 1;
            for (int n = 0; n < k; n++)
                if (sizes[j])
                    j -= 2;
                else
                    j--;

            CtClass[] locals = new CtClass[j + 1];
            copy(prevLocals, locals, 0, j + 1);
            BasicBlock bb = new BasicBlock(locals, new CtClass[0],
                                           blocks[index].offset + offsetDelta + 1);
            blocks[++index] = bb;
        }

        public void appendFrame(int pos, int offsetDelta, int[] tags, int[] data)
            throws BadBytecode
        {
            ArrayList<CtClass> array = new ArrayList<CtClass>(blocks[index].locals.length);
            for (CtClass cc: blocks[index].locals)
                array.add(cc);

            BasicBlock bb = new BasicBlock(toCtClassArray(array, tags, data),
                                           new CtClass[0], blocks[index].offset + offsetDelta + 1);
            blocks[++index] = bb;
        }

        public void fullFrame(int pos, int offsetDelta, int[] localTags, int[] localData,
                              int[] stackTags, int[] stackData)
            throws BadBytecode
        {
            ArrayList<CtClass> array = new ArrayList<CtClass>(localTags.length);
            CtClass[] locals = toCtClassArray(array, localTags, localData);
            ArrayList<CtClass> array2 = new ArrayList<CtClass>(stackTags.length);
            CtClass[] stack = toCtClassArray(array2, stackTags, stackData);
            BasicBlock bb = new BasicBlock(locals, stack,
                                           blocks[index].offset + offsetDelta + 1);
            blocks[++index] = bb;
        }

        CtClass[] toCtClassArray(ArrayList<CtClass> array,
                                 int[] tags, int[] data) throws BadBytecode
        {
            for (int i = 0; i < tags.length; i++) {
                CtClass cc = toCtClass(tags[i], data[i]);
                array.add(cc);
                if (cc != null && cc.isPrimitive() && ((CtPrimitiveType)cc).getDataSize() > 1)
                    array.add(null);
            }

            return array.toArray(new CtClass[array.size()]);
        }

        CtClass toCtClass(int tag, int data) throws BadBytecode {
            switch (tag) {
            case StackMapTable.TOP :
                return TOP;
            case StackMapTable.INTEGER :
                return CtClass.intType;
            case StackMapTable.FLOAT :
                return CtClass.floatType;
            case StackMapTable.DOUBLE :
                return CtClass.doubleType;
            case StackMapTable.LONG :
                return CtClass.longType;
            case StackMapTable.NULL :
                return NULL;
            case StackMapTable.THIS :
                return null;
            case StackMapTable.OBJECT :
                try {
                    return classPool.getCtClass(constPool.getClassInfo(data));
                } catch (NotFoundException e) {
                    throw new BadBytecode(e.getMessage());
                }
            case StackMapTable.UNINIT :
                return null;
            default :
                return null;
            }
        }
    }

    public static final CtClass NULL, TOP;
    public CtClass[] locals, stack;
    public int offset, length;

    static {
        ClassPool cp = new ClassPool();
        NULL = cp.makeClass("*NULL*");
        TOP = cp.makeClass("*TOP*");
    }

    static void copy(CtClass[] src, CtClass[] dest, int offset, int len) {
        for (int i = 0; i < len; i++)
            dest[i + offset] = src[i];
    }

    static CtClass[] getInitLocals(ClassPool cp, CtClass clazz, MethodInfo minfo)
        throws NotFoundException
    {
        String desc = minfo.getDescriptor();
        int size = Descriptor.paramSize(desc);
        CtClass[] locals;
        int index;
        if ((minfo.getAccessFlags() & AccessFlag.STATIC) != 0) {
            // if minfo is a static method
            locals = new CtClass[size];
            index = 0;
        }
        else {
            locals = new CtClass[size + 1];
            locals[0] = clazz;
            index = 1;
        }

        CtClass[] params = Descriptor.getParameterTypes(minfo.getDescriptor(), cp);
        for (int i = 0; i < params.length; i++) {
            CtClass type = params[i];
            locals[index++] = type;
            if (type == CtClass.longType || type == CtClass.doubleType)
                locals[index++] = TOP;
        }

        return locals;
    }

    public static BasicBlock[] make(ClassPool cp, CtBehavior method)
        throws BadBytecode, NotFoundException
    {
        MethodInfo minfo = method.getMethodInfo2();
        CodeAttribute ca = minfo.getCodeAttribute();
        if (ca == null)
            return new BasicBlock[0];

        CtClass clazz = method.getDeclaringClass();
        StackMapTable smt = (StackMapTable)ca.getAttribute(StackMapTable.tag);
        if (smt == null)
            if (clazz.getClassFile2().getMajorVersion() < ClassFile.JAVA_6) {
                minfo.rebuildStackMap(cp);
                smt = (StackMapTable)ca.getAttribute(StackMapTable.tag);
            }

        BasicBlock[] blocks;
        if (smt == null) {
            BasicBlock bb = new BasicBlock(getInitLocals(cp, clazz, minfo), new CtClass[0]);
            blocks = new BasicBlock[] { bb };
        }
        else {
            Reader reader = new Reader(smt, cp, clazz, minfo);
            reader.parse();
            blocks = reader.getBlocks();
        }

        blocks[0].offset = 0;
        setLength(blocks, ca);
        return blocks;
    }

    private static void setLength(BasicBlock[] blocks, CodeAttribute ca) {
        for (int i = 1; i < blocks.length; i++)
            blocks[i - 1].length = blocks[i].offset - blocks[i - 1].offset;

        blocks[blocks.length - 1].length
            = ca.getCodeLength() - blocks[blocks.length - 1].offset;
    }

    public BasicBlock(CtClass[] locals, CtClass[] stack) {
        this(locals, stack, -1);
    }

    public BasicBlock(CtClass[] locals, CtClass[] stack, int offset) {
        this.locals = locals;
        this.stack = stack;
        this.offset = offset;
        this.length = 0;    // set later by setLength().
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{offset=").append(offset).append(", {");
        toString(sb, locals);
        sb.append("}, {");
        toString(sb, stack);
        sb.append("}}");
        return sb.toString();
    }

    private void toString(StringBuilder sb, CtClass[] types) {
        for (CtClass cc: types)
            if (cc == null)
                sb.append("?, ");
            else if (cc == TOP)
                sb.append("<TOP>, ");
            else if (cc == NULL)
                sb.append("null, ");
            else
                sb.append(cc.getName()).append(", ");
    }
}
